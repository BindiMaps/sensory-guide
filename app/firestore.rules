rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Super admin emails - can read any venue for support
    function isSuperAdmin() {
      return request.auth != null &&
             exists(/databases/$(database)/documents/config/superAdmins) &&
             request.auth.token.email in get(/databases/$(database)/documents/config/superAdmins).data.emails;
    }

    // Legacy super admin check (fallback if config doc doesn't exist yet)
    function isSuperAdminFallback() {
      return request.auth != null &&
             request.auth.token.email in ['keith@bindimaps.com'];
    }

    // Combined super admin check
    function isAnySuperAdmin() {
      return isSuperAdmin() || isSuperAdminFallback();
    }

    // Check if user is approved for venue creation (on allow-list or super admin)
    function isApprovedUser() {
      return request.auth != null && (
        isAnySuperAdmin() ||
        (exists(/databases/$(database)/documents/config/access) &&
         request.auth.token.email in get(/databases/$(database)/documents/config/access).data.allowedEmails)
      );
    }

    // Check if user is an editor of the venue
    function isEditor(venueData) {
      return request.auth != null &&
             request.auth.token.email in venueData.editors;
    }

    // Check if the update would leave at least one editor
    function hasAtLeastOneEditor() {
      return request.resource.data.editors.size() >= 1;
    }

    // Venues collection
    match /venues/{venueId} {
      // Public read: Allow unauthenticated read of published venues (for public guide access)
      // Authenticated read: Must be editor OR super admin
      allow read: if (resource.data.status == 'published') ||
                     isEditor(resource.data) ||
                     isAnySuperAdmin();

      // Create: Disabled client-side - use createVenue Cloud Function instead
      // This ensures allow-list check is always enforced server-side
      allow create: if false;

      // Update: Must be editor AND can't remove all editors
      allow update: if isEditor(resource.data) && hasAtLeastOneEditor();

      // Delete: Must be editor AND must be the last editor
      allow delete: if isEditor(resource.data) && resource.data.editors.size() == 1;

      // Progress subcollection - editors can read transform progress
      match /progress/{progressId} {
        allow read: if isEditor(get(/databases/$(database)/documents/venues/$(venueId)).data) || isSuperAdmin();
        allow write: if false; // Only Cloud Functions can write
      }
    }

    // Config collection for super admin list (read-only)
    match /config/{docId} {
      allow read: if request.auth != null;
      allow write: if false;
    }

    // LLM Logs - users can read their own logs, writes only via Functions (Admin SDK)
    match /llmLogs/{logId} {
      allow read: if request.auth != null &&
                    request.auth.token.email == resource.data.userEmail;
      allow write: if false; // Only Cloud Functions can write
    }

    // Usage tracking - users can read their own usage, writes only via Functions
    match /usage/{userEmail}/daily/{date} {
      allow read: if request.auth != null &&
                    request.auth.token.email == userEmail;
      allow write: if false; // Only Cloud Functions can write
    }

    // Default deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
